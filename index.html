<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PracticeTrack</title>
    <!-- Include React -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <!-- Include Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Include Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.min.js"></script>
    
    <!-- Babel for JSX support -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #f5f5f5;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <!-- StorageManager Script -->
    <script type="text/babel">
        class StorageManager {
            constructor() {
                this.dbName = 'PracticeTrackDB';
                this.dbVersion = 1;
                this.localStorageKey = 'practicetrack_backup';
                this.db = null;
                this.isIndexedDBSupported = 'indexedDB' in window;
            }

            async init() {
                if (!this.isIndexedDBSupported) {
                    console.warn('IndexedDB not supported, falling back to localStorage');
                    return this._loadFromLocalStorage();
                }

                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.dbVersion);

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        
                        if (!db.objectStoreNames.contains('categories')) {
                            const categoryStore = db.createObjectStore('categories', { keyPath: 'id' });
                            categoryStore.createIndex('name', 'name', { unique: true });
                        }
                        
                        if (!db.objectStoreNames.contains('sessions')) {
                            const sessionStore = db.createObjectStore('sessions', { 
                                keyPath: 'id', 
                                autoIncrement: true 
                            });
                            sessionStore.createIndex('date', 'date', { unique: false });
                            sessionStore.createIndex('categoryId', 'categoryId', { unique: false });
                        }
                        
                        if (!db.objectStoreNames.contains('media')) {
                            db.createObjectStore('media', { keyPath: 'id' });
                        }
                        
                        if (!db.objectStoreNames.contains('settings')) {
                            db.createObjectStore('settings', { keyPath: 'key' });
                        }
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        console.log('Database initialized successfully');
                        resolve();
                    };

                    request.onerror = (event) => {
                        console.error('Error opening database:', event.target.error);
                        reject(`IndexedDB error: ${event.target.error}`);
                        
                        this._loadFromLocalStorage();
                    };
                });
            }

            async _backupToLocalStorage(data) {
                try {
                    const backupData = {
                        categories: data.categories || [],
                        sessions: data.sessions ? data.sessions.map(session => {
                            const sessionCopy = {...session};
                            if (sessionCopy.media && sessionCopy.media.blob) {
                                sessionCopy.media = {
                                    id: sessionCopy.media.id,
                                    type: sessionCopy.media.type
                                };
                            }
                            return sessionCopy;
                        }) : [],
                        settings: data.settings || {}
                    };
                    
                    localStorage.setItem(this.localStorageKey, JSON.stringify(backupData));
                    console.log('Data backed up to localStorage');
                } catch (error) {
                    console.error('Error backing up to localStorage:', error);
                }
            }

            _loadFromLocalStorage() {
                try {
                    const data = localStorage.getItem(this.localStorageKey);
                    return data ? JSON.parse(data) : { categories: [], sessions: [], settings: {} };
                } catch (error) {
                    console.error('Error loading from localStorage:', error);
                    return { categories: [], sessions: [], settings: {} };
                }
            }

            async getCategories() {
                if (!this.isIndexedDBSupported || !this.db) {
                    const data = this._loadFromLocalStorage();
                    return data.categories || [];
                }

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['categories'], 'readonly');
                    const store = transaction.objectStore('categories');
                    const request = store.getAll();

                    request.onsuccess = (event) => {
                        resolve(event.target.result);
                    };

                    request.onerror = (event) => {
                        console.error('Error fetching categories:', event.target.error);
                        reject(`Error fetching categories: ${event.target.error}`);
                    };
                });
            }

            async getSessions() {
                if (!this.isIndexedDBSupported || !this.db) {
                    const data = this._loadFromLocalStorage();
                    return data.sessions || [];
                }

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['sessions'], 'readonly');
                    const store = transaction.objectStore('sessions');
                    const request = store.getAll();

                    request.onsuccess = (event) => {
                        resolve(event.target.result);
                    };

                    request.onerror = (event) => {
                        console.error('Error fetching sessions:', event.target.error);
                        reject(`Error fetching sessions: ${event.target.error}`);
                    };
                });
            }

            async getSessionsWithMedia() {
                try {
                    const sessions = await this.getSessions();
                    
                    if (!this.isIndexedDBSupported || !this.db) {
                        return sessions;
                    }
                    
                    return sessions.sort((a, b) => new Date(b.date) - new Date(a.date));
                } catch (error) {
                    console.error('Error loading sessions with media:', error);
                    throw error;
                }
            }

            async addSession(session) {
                if (!this.isIndexedDBSupported || !this.db) {
                    const data = this._loadFromLocalStorage();
                    data.sessions.push(session);
                    this._backupToLocalStorage(data);
                    return session;
                }

                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['sessions'], 'readwrite');
                    const store = transaction.objectStore('sessions');
                    const request = store.add(session);

                    request.onsuccess = () => {
                        this._backupToLocalStorage({ sessions: [session] });
                        resolve(session);
                    };

                    request.onerror = (event) => {
                        console.error('Error saving session:', event.target.error);
                        reject(`Error saving session: ${event.target.error}`);
                    };
                });
            }
        }

        // Create a singleton instance
        window.storageManager = new StorageManager();
    </script>
    
    <!-- Main Application Script -->
    <script type="text/babel">
        // Rest of the PracticeTrackApp component remains the same as in the original code
        const PracticeTrackApp = () => {
            // [Previous implementation remains the same]
            
            // Modify savePracticeSession to use StorageManager
            const savePracticeSession = async () => {
                const newSession = {
                    id: Date.now(),
                    date: new Date().toISOString(),
                    category: selectedCategory,
                    subcategory: selectedSubcategory,
                    duration: elapsedTime,
                    notes: notes,
                    synced: false,
                    media: mediaData
                };
                
                try {
                    // Use StorageManager to save the session
                    await window.storageManager.addSession(newSession);
                    
                    setPracticeHistory(prev => [newSession, ...prev]);
                    setLastSavedSession(newSession);
                    
                    // Reset form
                    setElapsedTime(0);
                    setSelectedCategory('');
                    setSelectedSubcategory('');
                    setNotes('');
                    setMediaData(null);
                    setIsTimerRunning(false);
                } catch (error) {
                    console.error('Error saving session:', error);
                    alert('Error saving practice session');
                }
            };

            // Rest of the component implementation remains the same
            
            return (
                // [Previous implementation remains the same]
            );
        };

        // Initialize the app when the document is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize lucide icons
            lucide.createIcons();
            
            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(React.createElement(PracticeTrackApp));
        });
    </script>
</body>
</html>
